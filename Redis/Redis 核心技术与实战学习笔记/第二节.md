# Redis 有哪些慢操作

### 1、redis 底层的数据结构

String  → 简单动态字符串 SDS

List → quicklist

Hash → 哈希表 和 压缩列表

Sorted Set → 压缩列表 和 跳表

Set → 哈希表 和 整数数组

------

List 3.2 版本以前使用压缩列表和双向链表两种数据结构；默认使用压缩链表，当单个value长度超过64或压缩列表长度超过512时，处于性能考虑，redis 会将压缩列表转成双向链表（压缩列表在长度长时，每次修改元素会出现大量数据拷贝操作）；3.2 版本后底层实现改成了quickList，它类似于压缩列表和双向链表的混合体，每个节点是压缩列表，之前通过双向链表链接

### 2、如何快速找到键值

答案：哈希表，Redis 中的键和值均存储在hash表中，通过计算键的hash值将数据存储到哈希桶中，在取的时候通过hash值找到 entry 数据，通过 entry 中的 *value 指针获取到存储的值。

### 3、hash 冲突如何解决？

使用 hash 无法避免的是hash冲突的发生，Redis 使用链式hash 来解决，如果有多个元素通过hash 计算出的地址一致，就会将这些元素使用链表来保存；当hash链较长时会导致查询耗时过长，这时就会进行rehash 

### 4、渐进式rehash是如何工作的

当redis 没有bgsave时且负载因子≥1时或正在bgsave且负载因子≥5时；当负载因子<0.1时会进行缩容

进行rehash时会给哈希表2分配2倍哈希表1的空间，在rehash时在拷贝数据到哈希表2的同时释放哈希表1的空间

由于redis 的单线程模型，如果直接进行rehash，就会导致线程阻塞，无法服务其他请求，因此redis 采用的渐进式的rehash

在每次增删改查请求中，同时会从哈希表的第一个位置开始，将数据拷贝到哈希表2中，并将数据从哈希表1中删除，下一次请求再拷贝第二个位置，依次直到哈希表1中数据被清空。

### 5、不同数据结构下查询数据的时间复杂度是什么

哈希表 → O(1)

整数数组 → O(n)

跳表 → O(logn)

双向链表 → O(n)

压缩列表 → O(n)

quickList → O(n)

了解以上底层数据结构的时间复杂度，就可以推断出redis各个数据类型操作的时间复杂度了；

例如，String 的操作set、get、incr、del 等均是 O(1)；

List 的操作 Lpush、Rpop时间复杂度O(1)，Lindex 时间复杂O(n)，因为quicklist特性，返回首尾元素的时间复杂度就是 O(1)

同时，如果需要范围操作，那么时间复杂度就是变成O(n)，如果数据较多可能会导致阻塞，通常建议使用scan操作来避免一次性遍历所有数据返回(scan 命令每次执行时间复杂度O(1)，总时间复杂度仍为 O(n)）（这里n是指所需数据的数量）