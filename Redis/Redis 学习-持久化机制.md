# Redis学习-持久化机制

### AOF 日志

#### 实现原理
**日志结构**

AOF 日志整体由 redis 写命令组成，命令被追加在日志结尾。每个写命令写入日志，由`*n`表示当前命令有 n 个部分组成，每个部分均由`$n`开头，这里的 n 表示这部分的命令有多少字节组成

**写入方式**

为保证日志写入效率，在写入时不会对命令进行语法检测，因此，为了命令的正确性，redis 会在写命令执行后再将命令写入 AOF 日志中（还有个好处是不会阻塞写命令的执行）；具体步骤大致如下：

- 写命令触发AOF
- 执行写命令
- 将写命令写入缓冲区
- 将缓冲区数据落入磁盘

**故障恢复**

因为是将所有写命令记录入日志，因此在发生故障，进行恢复时，将 AOF 日志从开始执行一遍即可。

#### 可靠性保证

根据上面的写入方式，因为是先执行命令，再写入日志，如果写命令执行完后发生宕机，就可能会丢失数据。因此必须要一个可靠的写入策略，来最大程度的保证命令写入不会丢失。

redis 提供了三种磁盘写入策略，根据实际场景进行选择：

- Always：每次执行命令后立刻写入磁盘
- Everysec：执行完命令，将命令写入缓冲区，每隔 1s 将缓冲区数据写入磁盘
- No：同 Everysec，但是将缓冲区数据写入磁盘的时机交由操作系统来控制

显然，三种方式的可靠性依次降低，但其效率依次上升。如果想要高性能，能接受数据丢失，就选择 No；要求高可靠性，就选择 Always。

#### 重写机制

日志文件是不断的 append，所以会越来越大，会导致写入缓慢，故障恢复缓慢，因此，redis 会对日志进行重写。重写为不阻塞主线程，主线程会 fork 一个子线程来执行重写过程。重写时会读取 redis 中所有的数据，并把每一条数据转为一条写命令写入新的 AOF 日志中，最后会用新的 AOF 日志替代原日志；

在重写时，主线程依旧可以执行写命令，但这条命令不仅会被记入原 AOF 日志，也会被写入新的 AOF 日志中。

**重写触发**

- 可以在 redis.conf 配置重写的时机：

```
# AOF 文件大小超过基准文件的 2 倍时触发
# 基准文件由两种确定
# 故障恢复时的 AOF 文件作为基准文件
# 重写完成的 AOF 文件作为基准文件
auto-aof-rewrite-percentage 100
# AOF 文件大小超过 64mb 会触发重写
auto-aof-rewrite-min-size 64mb
```

- 执行`BGREWRITEAOF`命令主动触发重写
- `CONFIG SET`命令触发重写。

### RDB 快照

#### 实现原理

RDB 是一种快照数据，将某一时间点的内存数据落入磁盘；在故障恢复时可以直接加载到内存，达到快速恢复的目的。

**写入方式**

redis 提供了两种命令写入快照，save 和 bgsave

- Save: 在主线程中进行，执行快照时会阻塞，无法提供服务
- Bgsave：fork 一个子线程，RDB 由子线程进行，主线程仍正常提供服务

**RDB 触发**

- redis 中配置 save 参数，触发 bgsave，如`save 60 900`，含义是 60s 内有 900 次写入时触发 RDB
- 节点同步数据时，master 触发 bgsave
- Shutdown 时触发 save 命令

**写时复制**

子线程 RDB 时，如果主线程有写请求，就会丢失这部分数据，redis 采用写时复制来处理这个问题。fork 的子线程共享主线程的内存数据（不是copy主线程的物理内存，是copy父进程的页表），子线程运行后直接读取父线程的数据，因为copy是父进程的页表，如果父线程有写操作对子线程来说是不知道的；如果父线程有写请求，就会在将被写的那部分数据复制一个交给子线程，子线程读取这部分内存数据写入RDB中。

#### RDB 会出现的问题

1、RDB 保存的是快照数据，如果两次 RDB 之间出现宕机，就会丢失这部分数据

2、RDB 如果频次频繁会阻塞主线程请求，快照落磁盘也会因为频繁写磁盘导致磁盘压力过大，写入缓慢

### RDB-AOF 混合模式

redis 4.0 后提供了一个新的持久化模式，RDB-AOF 混合模式，开启方式是``aof-use-rdb-preamble=yes`

该模式混合了 RDB-AOF 的特点，RDB 做全量快照，两次 RDB 之间的数据使用 AOF 日志，当第二次 RDB 时，将 AOF 日志清空重写日志；

- fork 子线程
- 子线程执行 RDB 动作，写入的 AOF 文件中
- 让后将缓冲区的增量写命令追加 AOF 文件中
- 将新的 AOF 文件替换旧的 AOF 文件

因此混合模式的 AOF 文件中有两种格式数据：一部分是 RDB 快照数据，一部分是 AOF 日志；
而在出现故障恢复时，如果文件开头是 RDB 数据，先加载 RDB 数据，如果有 AOF 数据，再执行 AOF 写入的命令；如果开头是 AOF 日志，那么直接执行写命令；

### 总结

RDB 策略是 redis 默认持久化策略，因为保存的是内存快照数据，因此恢复数据效率很高，但是可能会丢失部分数据；

AOF 日志是追加写命令，会出现日志文件过大，恢复数据比较缓慢。

如果想做到不丢失数据，又可以有较好的性能，可以使用混合 AOF 和 RDB 的方式，开启方式是配置`aof-use-rdb-preamble`参数，RDB 频次可以调整到合适时间点，AOF 日志因为在下一次 RDB 时被清空，所以也不会导致日志文件大的问题，是一种两全的方案，缺点是无法兼容以前版本的redis。

如果 4.0 版本以上，数据不能丢失，建议使用混合模式；如果 4.0 以下，可以接受数据丢失，可以只使用 RDB 模式；如果使用 AOF 日志，建议使用 Everysec 模式。

### 持久化的一些问题

#### 重写过程是否有阻塞风险？如果有，会在哪里？

答：会有阻塞风险，具体在下面两个地方：

1、在 fork 子进程时，fork瞬间会阻塞主线程

2、新 AOF日志重写完成，父线程接管，产生写入的时候

当子线程完成工作，发出型号给父线程后，父线程接管，这是有写命令进入，会同时写入两个日志，这里会产生阻塞，写入后将新AOF覆盖旧AOF，此时也会阻塞

实际场景：

https://blog.csdn.net/github_32521685/article/details/106354737



### 参考链接

[redis灵魂拷问：聊一聊AOF日志重写](https://blog.csdn.net/zjj2006/article/details/109045767)

[redis4.0之RDB-AOF混合持久化](https://developer.aliyun.com/article/193034)

[Redis写时拷贝（COW）总结](https://www.cnblogs.com/jelly12345/p/15223184.html)