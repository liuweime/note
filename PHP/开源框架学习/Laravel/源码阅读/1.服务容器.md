---
Date: 2022/09/25 14:30
Address: 合肥
---

# 1. 服务容器

首先，要知道服务容器的思路是来自于什么设计思想。

设计模式的五大原则分别是：

- 单一职责
- 开闭原则
- 里氏替换
- 接口隔离
- 依赖倒置 DIP

其中，依赖倒置被描述为，模块/方法之间的依赖基于抽象，而不是具体实现。当整个项目依赖倒置化后，所有方法都依赖于抽象或接口，对于下层服务来说，不需要关心其实现；而对于上层服务，调用下层服务时就需要实例化不同类传递。通常使用使用控制反转来解决这种被下层服务控制的问题，而实现控制反转的方法就是 IoC-服务容器。

服务容器了解下层服务的依赖，可以实现对类的自动注入。实现这种依赖注入的基础是反射。

Laravel 服务容器位置是：

> /vendor/laravel/framework/src/Illuminate/Container/Container.php

阅读源码之前，建议先了解一下容器中的属性。

```php
// 受保护的静态属性 用于存储容器实例 
// 可以用于构建生命周期全可用的容器
protected static $instance;

// 一个 bool 类型的数组 对已解析过的类进行标记
// 格式 抽象类 => false/true
// 存在该信息 可以在绑定时就重新构建该对象实例
protected $resolved = [];

// 存储绑定中的类信息二维数组
// 通常存储两个字段：
// concrete: 要实例化的类或回调函数
// shared：bool，用于标记该类是否全局可用(单例)，=true 后续会实例化成单例
protected $bindings = [];

// 该属性存储的是回调数组
// laravel容器允许绑定单个回调方法
// 可以通过 container::call 进行全局调用
protected $methodBindings = [];

// 存储的是实例化后的对象
// 通过单例绑定的类（singleton方法绑定，或bind shared=true） 构建后会存储到该属性中
// 可以作为单例使用
protected $instances = [];


// 存储的是绑定类的别名
// 别名主要是代替完整的类名 并提供同样的访问流程
protected $aliases = [];

// 存储的是被标记的类数组
// 可以通过给多个类进行标记
// 通过tagged方法一并解析
protected $tags = [];

// TODO 暂时没理解其作用
protected $buildStack = [];

// 参数数组
// 用于解析类，构建参数穿入
protected $with = [];

// ？上下文绑定
public $contextual = [];

// 存储的是重新绑定的回调函数
protected $reboundCallbacks = [];
```



带着上面属性，来看下容器的具体实现。
