# MySQL 复习(2)：事务

## 事务特性

一个标准事务拥有原子性、一致性、隔离性、持久性四大特性。

**原子性**

简单的说就是事务中 sql 的执行要么一起成功，要么一起失败：

- insert：回滚会执行 delete 操作;
- delete：回滚会执行 insert 操作；
- update: 回滚会执行相反的 update 操作；

InnoDB 使用`undo log`来记录事务中所有执行修改的操作，记录的是修改前旧版本的数据。其中 insert 产生的`undo log` 事务提交会直接删除，update、delete 会存入磁盘(因为MVCC的需要)。

简略的描述一下事务进行中undo log记录：

> BEGIN;
> 修改字段 a=10;   
> // 修改之前记录 a = 5 到undo log；修改后将 a = 10 存入 redo log
> 删除记录 id = 1; 
> // 删除之前将记录 id = 1 到undo log；删除后将删除记如 redo log
> COMMIT;    
> // 事务提交前 持久化undo log redo log到磁盘；事务提交后，将数据持久到磁盘中

如果MySQL出了错误或执行了 rollback 操作，那么就可以利用 undo log 执行回滚操作，恢复到事务之前的状态。

**持久性**

事务提交后数据就保留在数据库中。

undo log 保证了事务的原子性，redo log 用来保证事务的持久性。InnoDB 将数据修改前的数据保存入 undo log，将新数据存入 redo log，两个 log 都会在事务提交之前存入磁盘中。

如果在 redo log 持久化之前 MySQL 崩溃，此时数据未持久到磁盘中，可以利用 undo log 进行回滚；如果 redo log 持久化后崩溃，MySQL 启用后可以利用 redo log 恢复数据到最新。

**隔离性**

多个事务执行并发执行，在事务提交之前对其他事务是不可见的。隔离性的要求并不如定义的那么严格，因为满足该定义的事务必然是串行的，会很大的影响并发。所以通常数据库定义了四种隔离级别用于不同需求，隔离性从低到高分别为：可串行、可重复读、提交读、未提交读。

通常高一级别的隔离解决了上一个级别的主要问题，如 RR 解决了 RC 导致的不可重读问题，但是留下了幻读的问题，InndoDB 默认的隔离级别是RR，因为使用了 MVCC，实现了快照读功能，一定程度上解决了幻读。不过毕竟只是 RR 级别，在 insert 或 update 操作后其结果可能会与预期不一致。

在下面事务的隔离级别中将详细阐述四种事务隔离级别以及会导致的问题。

**一致性**

这里的一致性与CAP理论中的一致性不一样，CAP 是分布式系统中的理论，分布式下所有节点数据保持一致。

这里的一致大致可以分成数据库一致和用户一致性。

举个例子，银行转账举例，a 往 b 账户转账 1000 元，a 账户减少 1000元，b 账户增加 1000 元，事务结束后 a 、b 账号金额总和与事务执行之前保持一致。这是就是由用户定义的一致性，对于数据库来说 a 账号减少 1000，b 账号增加50，事务的执行也是成功的，不影响其数据库一致性。

数据库一致性一般定义为数据从一个有效状态到另一个有效的状态。什么是有效的状态，维基中说明数据写入要满足数据库定义的规则、约束，满足的即可写入数据库。可以简单介绍为遵循了数据库定义的规则和约束的数据才会被写入数据库，否则数据库将恢复到之前的状态。

## 事务的隔离级别

事务的隔离级别分成四种：未提交读、提交读、可重复读、可串行化。

**未提交读**是最低的隔离级别，意思是事务可以读取到其他未提交事务的修改，该级别下会出现**脏读**现象。脏读，无效的数据被读取，未被提交的事务所做的修改可以认为是无效的，因为其随时可能会回滚。

**提交读**，事务可以读取到提交后的事务所做的修改，该级别不允许读取到未提交事务的修改，也就是不允许脏读，但是因为能够读取到提交后事务的改动，会导致不可重读现象。不可重读，也就是同一行记录的两次查询结果不一致。

**可重读**，可重复读下最令人疑惑的概念就是幻读，百度百科与维基百科的定义就不太一致，这里取维基中的定义：在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。即，事务 A 某次读取数据返回 n 个结果，之后事务 B 添加了一条数据，事务 A 再次读取数据时发现返回了 n + 1 个结果。

幻读令人疑惑的还有，某数据表 a 字段是唯一索引，事务 A 与 事务 B 同时操作，事务 B 插入了一条数据 a = 10 并提及，事务 A 的操作是查询是否有 a = 10 的记录，没有就将a =10 插入表中，操作的结果是数据库触发了唯一索引的报错。这种属于幻读吗。

InnoDB RR 级别在文档中说明了已解决了幻读问题，同时指出了仅适用于 SELECT 语句，对于 update 、insert、delete 后提交事务，这些更改对当前事务是可见的。想完全解决问题该怎么办，只有继续提升隔离级别，使用可串行化，保证多个事务串行运行。

MVCC 对于解决不可重读、幻读问题做了很大贡献，InnoDB 的 RC、RR 级别都使用 MVCC，下一篇笔记将着重来复习MVCC的原理与实现。